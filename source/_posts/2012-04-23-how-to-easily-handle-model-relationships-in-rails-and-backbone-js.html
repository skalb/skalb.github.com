---
layout: post
title: How to (easily) handle model relationships in Rails and Backbone.js
tags:
- Backbone
- CoffeeScript
- EJS
- JavaScript
- Programming
- Rails
- Ruby
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  keywords: ! 'Backbone, Backbone.js, JavaScript, Coffeescript, Ruby, EJS, Rails,
    Models, Views, Templates, Single page, '
  description: Tutorial building a very basic single page project management app using
    Rails and Backbone.
  title: How to (easily) handle model relationships in Rails and Backbone.js
  robotsmeta: index,follow
  _avia_elements_avia_options_sentence: a:3:{s:15:"_slideshow_type";s:11:"fade_slider";s:19:"_slideshow_autoplay";s:5:"false";s:19:"_slideshow_duration";s:1:"5";}
  _avia_elements_theme_compatibility_mode: a:3:{s:15:"_slideshow_type";s:11:"fade_slider";s:19:"_slideshow_autoplay";s:5:"false";s:19:"_slideshow_duration";s:1:"5";}
  _facebookcount-cache: '0'
  _twittercount-cache: '1'
---
While playing around with Backbone.js, I couldn't find an easy way to build an app that used the RESTful hierarchy of my models. I think <a href="http://spinejs.com/docs/relations">Spine's</a> implementation is fairly straightforward.

I did find a&nbsp;relevant&nbsp;<a href="https://github.com/PaulUithol/Backbone-relational">active project</a>, but for my specific case the added complexity of an additional component and dependency didn't seem justified. Rails already does the hard part for me, I just need Backbone to call the correct Urls.

I wanted to learn more about Backbone, so I prototyped a very basic project management app using Rails and Backbone called Trackbone that I'll walk through in this post.

<!--more-->

Briefly, this is a single page three panel app with drill-downs:
<ul>
	<li>Many projects</li>
	<li>Project has many Features</li>
	<li>Feature&nbsp;has many Bugs</li>
</ul>

<a href="http://young-flower-9677.herokuapp.com/">Demo on Heroku</a>
<a href="https://github.com/skalb/trackbone/tree/version1">Source</a> 

<strong>Rails backend:</strong>

Rails controllers provide the REST API for our Backbone app. I haven't inlined them here since they only have a few modifications post-scaffolding, but you can view them <a href="https://github.com/skalb/trackbone/tree/version1/app/controllers">here</a>

Modifications:
<ul>
<li>Projects#index is moved to HomeController</li>
<li>Location is not returned in response after #create</li>
<li>Model is returned after #update</li>
</ul>

<span style="text-decoration: underline;">routes.rb</span>:
[ruby]
root :to =&gt; &quot;home#index&quot;

Trackbone::Application.routes.draw do
  resources :projects do
    resources :features do
      resources :bugs
    end
  end
end
[/ruby]

For setting up Backbone, the rails-backbone gem provides a good <a href="https://github.com/codebrew/backbone-rails/blob/master/README.md">guide</a>. 

Originally, I scaffolded Backbone here as well. On review, I'm not sure I would do that again. I think you'll end at a better design if you start from scratch.

<strong>Creating Backbone Models:</strong>

Features only exist in the context of a Project, so they should only be loaded for a specific Project and similarly for Bugs.

<span style="text-decoration: underline;">javascripts/backbone/models/project.js.coffee</span>:
[coffee]
class Trackbone.Models.Project extends Backbone.Model
  paramRoot: 'project'

  defaults:
    name: null

  loadFeatures: -&gt;
    @features = new Trackbone.Collections.FeaturesCollection([], {project_url: @url()});

class Trackbone.Collections.ProjectsCollection extends Backbone.Collection
  model: Trackbone.Models.Project
  url: '/projects'
[/coffee]

On reflection, loadFeatures is poorly named. It's really more of an 'initialize', but anyways, calling that method will create a FeaturesCollection and pass in the Url for this project. You can see how this is used in the Features model

<span style="text-decoration: underline;">javascripts/backbone/models/feature.js.coffee</span>:
[coffee]
class Trackbone.Models.Feature extends Backbone.Model
  paramRoot: 'feature'

  defaults:
    name: null

  loadBugs: -&gt;
    @bugs = new Trackbone.Collections.BugsCollection([], {feature_url: @url()});

class Trackbone.Collections.FeaturesCollection extends Backbone.Collection
  model: Trackbone.Models.Feature
  initialize: (model, args) -&gt;
    @url = -&gt;
      args.project_url + &quot;/features&quot;
[/coffee]

Using the project_url from args will prepend all RESTful requests made on the features model with projects/:project_id.

<span style="text-decoration: underline;">javascripts/backbone/models/bug.js.coffee</span>:
[coffee]
class Trackbone.Models.Bug extends Backbone.Model
  paramRoot: 'bug'

  defaults:
    name: null

class Trackbone.Collections.BugsCollection extends Backbone.Collection
  model: Trackbone.Models.Bug
  initialize: (model, args) -&gt;
    @url = -&gt;
      args.feature_url + &quot;/bugs&quot;
[/coffee]

<strong>Backbone Routers:</strong>

Next we need to create the Projects router which will be the entry point into our single page app.

<span style="text-decoration: underline;">javascripts/backbone/routers/projects_router.js.coffee</span>:
[coffee]
class Trackbone.Routers.ProjectsRouter extends Backbone.Router
  initialize: (options) -&gt;
    @projects = new Trackbone.Collections.ProjectsCollection()
    @projects.reset options.projects

  routes:
    &quot;.*&quot; : &quot;index&quot;

  index: -&gt;
    @view = new Trackbone.Views.Projects.IndexView(projects: @projects)
    $(&quot;#list-projects&quot;).html(@view.render().el)

    @newProjectView = new Trackbone.Views.Projects.NewView(collection: @projects)
    $(&quot;#new-projects&quot;).html(@newProjectView.render().el)
[/coffee]

Because we're not worrying about permalinks (yet! I've started looking into this, and hope to create a follow-up post), we only need one catch-all route. We then pass in the respective models to our views.

<strong>Listing projects:</strong>

Create <span style="text-decoration: underline;">views/projects/index.html.erb</span>:
[html]
&lt;h1&gt;Trackbone&lt;/h1&gt;
&lt;hr&gt;
&lt;div class=&quot;container&quot;&gt;
  &lt;div id=&quot;new-projects&quot;&gt;&lt;/div&gt;
  &lt;div id=&quot;list-projects&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;container&quot;&gt;
  &lt;div id=&quot;new-features&quot;&gt;&lt;/div&gt;
  &lt;div id=&quot;list-features&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;container&quot;&gt;
  &lt;div id=&quot;new-bugs&quot;&gt;&lt;/div&gt;
  &lt;div id=&quot;list-bugs&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
  $(function() {
    window.router = new Trackbone.Routers.ProjectsRouter(
      { projects: &lt;%= @projects.to_json.html_safe -%&gt; }
    );
    Backbone.history.start();
  });
&lt;/script&gt;
[/html]

There is a container, new, and list div for each model. Backbone will load data from our Rest API, build HTML using the Views and Templates and inject that HTML into those DIV elements. Note that we are passing in projects from Rails to the router. This allows us to grab data from the server when the page is first requested and save an additional call on page load. Since this is a single page app, this is the only Rails view we need.

To display our Project data we need three templates: index to list projects, project for a specific item, and new to create a project.

<span style="text-decoration: underline;">javascripts/backbone/templates/shared/item.jst.ejs</span>:
[html]
&lt;td&gt;&lt;a href=&quot;#&quot; class=&quot;select&quot;&gt;&lt;%= name %&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;#&quot; class=&quot;destroy&quot;&gt;Destroy&lt;/a&gt;&lt;/td&gt;
[/html]

<span style="text-decoration: underline;">javascripts/backbone/templates/projects/index.jst.ejs</span>:
[html]
&lt;h1&gt;Listing projects&lt;/h1&gt;

&lt;table id=&quot;projects-table&quot;&gt;
  &lt;tr&gt;
    &lt;th&gt;Name&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;br/&gt;
[/html]

<span style="text-decoration: underline;">javascripts/backbone/templates/projects/new.jst.ejs</span>:
[html]
&lt;h1&gt;New project&lt;/h1&gt;

&lt;form id=&quot;new-project&quot; name=&quot;project&quot;&gt;
  &lt;div class=&quot;field&quot;&gt;
    &lt;label for=&quot;name&quot;&gt; name:&lt;/label&gt;
    &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; value=&quot;&lt;%= name %&gt;&quot; &gt;
  &lt;/div&gt;

  &lt;div class=&quot;actions&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Create Project&quot; /&gt;
  &lt;/div&gt;

&lt;/form&gt;
[/html]

These should be fairly self-explanatory. Each template will also need a Backbone View as well.

<span style="text-decoration: underline;">javascripts/backbone/views/projects/index_view.js.coffee</span>:
[coffee]
Trackbone.Views.Projects ||= {}

class Trackbone.Views.Projects.IndexView extends Backbone.View
  template: JST[&quot;backbone/templates/projects/index&quot;]

  initialize: () -&gt;
    @options.projects.bind('reset', @addAll)
    @options.projects.bind('sync', @render)

  addAll: () =&gt;
    @options.projects.each(@addOne)

  addOne: (project) =&gt;
    view = new Trackbone.Views.Projects.ProjectView({model : project})
    @$(&quot;tbody&quot;).append(view.render().el)

  render: =&gt;
    $(@el).html(@template(projects: @options.projects.toJSON()))
    @addAll()

    return this
[/coffee]

This view receives the entire list of projects, renders the index view and appends a project view for each project.

<span style="text-decoration: underline;">javascripts/backbone/views/projects/new_view.js.coffee</span>:
[coffee]
Trackbone.Views.Projects ||= {}

class Trackbone.Views.Projects.NewView extends Backbone.View
  template: JST[&quot;backbone/templates/projects/new&quot;]

  events:
    &quot;submit #new-project&quot;: &quot;save&quot;

  save: (e) -&gt;
    e.preventDefault()
    e.stopPropagation()

    name = $(&quot;#new-project #name&quot;).val()
    if name
      $(&quot;#new-project #name&quot;).val('')
      @collection.create(name: name)

  render: -&gt;
    $(@el).html(@template())

    return this
[/coffee]

The new view simply providers a handler for creating a new project within the collection. The create method actually does three things: creates the model, POSTs the model to the server, and adds the model to the collection.

<span style="text-decoration: underline;">javascripts/backbone/views/projects/project_view.js.coffee</span>:
[coffee]
Trackbone.Views.Projects ||= {}

class Trackbone.Views.Projects.ProjectView extends Backbone.View
  template: JST[&quot;backbone/templates/shared/item&quot;]

  events:
    &quot;click .select&quot; : &quot;select&quot;
    &quot;click .destroy&quot; : &quot;destroy&quot;

  tagName: &quot;tr&quot;
  className: &quot;item&quot;

  select: () -&gt; 
    window.toggleSelected(@el)
    @model.loadFeatures()
    do (@model) -&gt;
      @model.features.fetch success: -&gt;
        featuresView = new Trackbone.Views.Features.IndexView(features: @model.features)
        $(&quot;#list-features&quot;).html(featuresView.render().el)

        # We should probably only render this once instead of each load
        newFeaturesView = new Trackbone.Views.Features.NewView(collection: @model.features)
        $(&quot;#new-features&quot;).html(newFeaturesView.render().el)

        $(&quot;#list-bugs&quot;).html('')
        $(&quot;#new-bugs&quot;).html('')
    @model.features.fetch()

  destroy: () -&gt;
    @model.destroy()
    this.remove()

    return false

  render: -&gt;
    $(@el).html(@template(@model.toJSON() ))
    return this
[/coffee]

This view is really the heart of the app. Every time a Project is selected, we'll display the Features for that Project by calling fetch() and binding to success(). 

I'm not going to inline the templates and views for Features and Bugs since they are more or less identical, but feel free to browse through all the <a href="https://github.com/skalb/trackbone/tree/version1/app/assets/javascripts/backbone">client side code</a>

Again, here's a working <a href="http://young-flower-9677.herokuapp.com/">demo</a>.

Please provide any feedback you have in the comments. Was this useful? Too long? Too much/too little code inline? I'm currently working on a couple more entires that will build on this one as I'm learning more about Backbone.js, so feedback is definitely useful.
